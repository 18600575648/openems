package io.openems.common.config;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map.Entry;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.TreeMap;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

import io.openems.common.exceptions.NotImplementedException;
import io.openems.common.utils.JsonUtils;
import io.openems.common.utils.Log;

public class ConfigUtils {

	private final static Charset DEFAULT_CHARSET = Charset.forName("UTF-8");

	protected static synchronized JsonArray readConfigFromFile(Path path) throws Exception {
		if (!Files.exists(path)) {
			throw new IOException("Configuration file [" + path.toAbsolutePath() + "] not found!");
		}
		String config = new String(Files.readAllBytes(path), DEFAULT_CHARSET);
		return JsonUtils.parse(config).getAsJsonArray();
	}

	protected static synchronized void writeConfigToFile(Path path, Collection<Config> configs) throws IOException {
		// sort configs by ID to write them sorted
		List<Config> sortedConfigs = new ArrayList<Config>(configs);
		Collections.sort(sortedConfigs, (a, b) -> a.getIdOpt().orElse("").compareTo(b.getIdOpt().orElse("")));

		// create JsonObject
		JsonArray j = new JsonArray();
		for (Config config : sortedConfigs) {
			if (config.isDoNotStore()) {
				// ignore configs that should not be stored
				continue;
			} else if (config.containsKey("factory.pid") && config.containsKey("factory.pidList")) {
				// ignore factory.pid configs: they are not necessary and are cluttering up the
				// config
				continue;
			}

			JsonObject jSub = new JsonObject();
			// sort map by key to be able to write the json array sorted
			TreeMap<String, Object> sortedSub = new TreeMap<>();
			for (Entry<String, Object> subEntry : config.entrySet()) {
				sortedSub.put(subEntry.getKey(), subEntry.getValue());
			}

			for (Entry<String, Object> subEntry : sortedSub.entrySet()) {
				String key = subEntry.getKey();
				if (key.endsWith(".target")) {
					// ignore. Those are generated by '{name}.ids' keys and do not need to be stored
					continue;
				} else if (key.equals("service.bundleLocation") || key.equals("service.pid")) {
					// ignore. Not required. Will be generated automatically.
					continue;
				}
				try {
					jSub.add(subEntry.getKey(), JsonUtils.getAsJsonElement(subEntry.getValue()));
				} catch (NotImplementedException e) {
					Log.warn("Unable to store [" + config.getIdOpt().orElse(config.getPid()) + "/" + subEntry.getKey()
							+ "] value [" + subEntry.getValue() + "] in config: " + e.getMessage());
				}
			}
			j.add(jSub);
		}

		// write to file
		Gson gson = new GsonBuilder().setPrettyPrinting().create();
		String config = gson.toJson(j);
		Files.write(path, config.getBytes(DEFAULT_CHARSET));
	}
}
